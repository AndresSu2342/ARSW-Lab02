Autores: Joan Acevedo - Cesar Borray

Parte II

Ejercicio

1. C贸digo analizado! 

2. Problemas identificados:

    2.1 Posibles condiciones de carrera:

    - La variable Board.gameboard representa el tablero u se accede en m煤ltiples partes del c贸digo sin sincronizaci贸n,
    en caso de que m煤ltiples serpientes intentaran actualizar la misma celda simult谩neamente, se podr铆an generar
    inconsistencias en el estado del tablero.
    - En checkIfFood(), la comida se verifica y actualiza sin protecci贸n contra accesos concurrentes, si m煤ltiples
    hilos intentaran modificar Board.food[i] al mismo tiempo, se puede sobrescribir informaci贸n inesperadamente.

    2.2 Uso inadecuado de colecciones:

    - snakeBody al ser una LinkedList, no es segura para el acceso concurrente, si otro hilo intenta leer o modificar
    snakeBody en el mismo instante, podr铆a generar una excepci贸n de concurrencia.

    2.3 Uso innecesario de esperas activas:

    - Thread.sleep(500) hace que el hilo se detenga por un tiempo fijo, sin considerar la carga del sistema o la
    necesidad real de la pausa, en caso de que el sistema se sobrecargue, la interfaz se podr铆a volver lenta.

3. Soluci贸n a los problemas identificados:

    2.1 Soluci贸n a posibles condiciones de carrera:

    - Para solucionar el problema con la variable gameboard, utilizaremos el synchronized en los m茅todos que la
    consultan o la modifican. Esto evitar谩 problemas de concurrencia cuando multiples hilos intenten leer y escribir
    en la matriz al mismo tiempo.

    Los m茅todos en los que se us贸 synchronized fueron "GenerateBoard()", "GenerateFood()", "GenerateBarriers()",
    "GenerateJumpPads()", "GenerateTurboBoosts()", "paintComponent" y en su constructor.

    2.2 Soluci贸n a uso inadecuado de colecciones:

    - Primero que nada, hicimos que el m茅todo "snakeCalc" fuera synchronized para evitar problemas de concurrencia y asi
    asegurarnos que solo un hilo pueda modificar "snakeBody" a la vez.

    Posteriormente, cambiamos el m茅todo ".peekLast" por ".pollLast", al hacer esto se elimina y se devuelve la 煤ltima
    celda en una sola operaci贸n at贸mica, evitando posibles errores de concurrencia.

    2.3 Soluci贸n a uso innecesario de esperas activas:

    - Para aprovechar la posibilidad de liberar el hilo de manera m谩s 贸ptima, procedemos a cambiar el
    "Thread.sleep(500)" por un "wait()" y un "notify".

    Para ello procedemos a crear un objeto tipo Object llamado "lock" el cual se va a usar para el synchronized que
    pondremos dentro de run(), posteriormente cambiamos el "Thread.sleep(500)" por un "lock.wait(500)".
